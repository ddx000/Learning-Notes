# SQL數據庫系統

## ACID
A: Atomic
C: Consistency 一致性
數據庫在事務執行前後都保持一致性狀態。在一致性狀態下，所有事務對同一個數據的讀取結果都是相同的。
I: Isolation 隔離性
- 主要是解決"並發"的問題
- 資料庫允許多個並發事務同時對其數據進行讀寫和修改的能力，隔離性可以防止多個事務並發執行時由於交叉執行而導致數據的不一致
- 在並發環境下，事務的隔離性很難保證，因此會出現很多並發一致性問題。  

D: 持久性

## 樂觀鎖和悲觀鎖
https://www.cnblogs.com/kismetv/p/10787228.html
- 樂觀鎖: 我認為你不會修改數據，所以只在提交時，檢查是否有人修改，若有人修改過，我就放棄此事務(使用版本號 CAS Compare And Swap )
> 樂觀鎖本身是不加鎖的，只是在更新時判斷一下數據是否被其他線程更新了


- 悲觀鎖: 我覺得你會修改數據，所以我一進去就加鎖
> 悲觀鎖的實現方式是加鎖，加鎖既可以是對代碼塊加鎖（如Java的synchronized關鍵字），也可以是對數據加鎖（如MySQL中的排它鎖）
- 如果高併發，適合悲觀鎖，因為樂觀鎖會一直失敗(大家都搶著修改，一直失敗)，一般不是高併發的情況下，適合樂觀鎖(因為衝突機會少，加鎖是需要資源的)

- 
## 封鎖粒度: 行級鎖以及表級鎖(MYSQL)
- InnoDB支持行級鎖(row-level locking)和表級鎖,默認為行級鎖


- 在選擇封鎖粒度時，需要在鎖開銷和並發程度之間做一個權衡。
- 應該盡量只鎖定需要修改的那部分數據，而不是所有的資源。鎖定的數據量越少，發生鎖爭用的可能就越小，系統的並發程度就越高。
- 因此封鎖粒度越小，系統開銷就越大。
### 行級鎖
- 一次只鎖一個row，優點: 併發程度高 缺點:系統開銷大，加鎖慢
行級鎖是mysql中鎖定粒度最細的一種鎖，表示只針對當前操作的行進行加鎖。行級鎖能大大減少數據庫操作的沖突。其加鎖粒度最小，但加鎖的開銷也最大
### 表級鎖
- 一次鎖一個table 優點: 系統開銷小 缺點: 併發程度低

## 封鎖類型:

互斥鎖（Exclusive），簡寫為X 鎖，又稱寫鎖。  
- 加互斥鎖後，就我獨佔，其他人都不能加鎖  

共享鎖（Shared），簡寫為S 鎖，又稱讀鎖。
- 大家都可以加S鎖 加上去後，大家都可以讀
- 加鎖期間其它事務能對A 加S 鎖，但是不能加X 鎖

## FOR UPATE:
pass



## SQLite
1. pd.read_csv超快 甚至比read_sql快很多
2. sqlite的優勢是select, 當資料越來越多時，pandas的做法是先進來後用loc或filter再去篩
3. 當未來資料越來越多時，一定需要**select的功能，不可能把全部的csv to df放進memory，很容易爆掉**
4. csv雖然可以分檔，但是要畫長時間圖時，只有sql才有辦法做到這件事情
![](https://i.imgur.com/zTBMs1D.png)

5. MYSQL是基於服務器，SQLite則是無服務器 輕量
6. SQLite不可以同時寫入(保持單線程



## ORM(Object Relational Mapping)
- 優點
1. 基本上就是物件導向的語法，開發快
2. 可以接任何接口(高階API)，方便轉移
3. 防止SQL注入攻擊
- 缺點
1. 不是原生 效能差 可自訂少 複雜的還是要自己寫